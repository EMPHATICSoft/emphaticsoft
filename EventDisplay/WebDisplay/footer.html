    //Design of this class heavily influenced by https://threejs.org/manual/#en/picking
    //TODO: We might want color-based picking instead of a raycaster one day.  three.js supports that too.  It would solve performance problems if we have lots of objects like GEANT hits.
    class PickHelper {
      constructor() {
        this.raycaster = new THREE.Raycaster();
        this.pickedObject = null;
        this.pickedObjectOldMaterial = new THREE.MeshPhongMaterial({
                                         color: 0xffff00,
                                         transparent: true,
                                         opacity: 1,
                                         side: THREE.DoubleSide
                                       });
        this.labelContainerElem = document.querySelector('#labels');
        this.labelElem = document.createElement('div');
      }

      pick(normalizedPosition, scene, camera) {
        if(this.pickedObject) {
          this.pickedObject.material = this.pickedObjectOldMaterial;
          this.pickedObject = undefined;
          this.labelContainerElem.removeChild(this.labelElem);
        }

        //Cast a ray through the camera lens.  three.js calls this the frustrum which is technically correct but always confuses me. 
        this.raycaster.setFromCamera(normalizedPosition, camera);
        const intersectedObjects = this.raycaster.intersectObjects(scene.children);
        if(intersectedObjects.length) {
          this.pickedObject = intersectedObjects[0].object;
          this.pickedObjectOldMaterial = this.pickedObject.material;
          //Make this object light up as long as the mouse hovers over it
          this.pickedObject.material = new THREE.MeshPhongMaterial({
                                         color: 0xffff00,
                                         transparent: true,
                                         opacity: 1,
                                         side: THREE.DoubleSide
                                       });

          //Draw a label next to this object
          const canvas = document.querySelector('#Display');
          const tempV = new THREE.Vector3();
          this.labelElem.textContent = this.pickedObject.name;
          this.labelContainerElem.appendChild(this.labelElem);

          //TODO: Positioning the label on top of the picked object messes up further picking.  Figure out why, then restore this code.
          /*this.pickedObject.updateWorldMatrix(true, false);
          this.pickedObject.getWorldPosition(tempV);

          tempV.project(camera);
          const x = (tempV.x *  .5 + .5) * canvas.clientWidth;
          const y = (tempV.y * -.5 + .5) * canvas.clientHeight;
          this.labelElem.style.transform = `translate(-50%, -50%) translate(${x}px,${y}px)`;*/
        }
      }
    }

    function main() {

      const canvas = document.querySelector('#Display');
      const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
    
      //Camera setup
      const fov = 75;
      const aspect = 2;
      const near = 0.1;
      const far = 1000;
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      camera.position.set(0, 30, -40);

      const controls = new OrbitControls(camera, canvas);
      controls.target.set(0, 0, 0);
      controls.update();

      //Light setup
      const lightColor = 0xFFFFFF;
      const intensity = 3;
      const light = new THREE.DirectionalLight(lightColor, intensity);
      light.position.set(-1, 2, -10);
    
      //Set up things to draw
      const scene = new THREE.Scene();

      setupSSDBoxes(scene);
      var [geomMaterial, ssdMaterial] = setupReferenceGeometry(scene);

      scene.add(light);
    
      function resizeRendererToDisplaySize(renderer)
      {
        const canvas = renderer.domElement;
        const pixelRatio = window.devicePixelRatio;
        const width = Math.floor(canvas.clientWidth * pixelRatio);
        const height = Math.floor(canvas.clientHeight * pixelRatio);
        const needsResize = canvas.width != width || canvas.height != height;
        if(needsResize) {
          renderer.setSize(width, height, false);
        }

        return needsResize;
      }

      //Set up object picking
      const pickPosition = {x: 0, y: 0};

      function getCanvasRelativePosition(event) {
        const rect = canvas.getBoundingClientRect();
        return {
          x: (event.clientX - rect.left) * canvas.width / rect.width,
          y: (event.clientY - rect.top) * canvas.height / rect.height
        };
      }

      const pickHelper = new PickHelper();

      //Start rendering!
      function render() {
        if(resizeRendererToDisplaySize(renderer))
        {
          const canvas = renderer.domElement;
          camera.aspect = canvas.clientWidth/canvas.clientHeight;
          camera.updateProjectionMatrix();
        }

        pickHelper.pick(pickPosition, scene, camera);

        renderer.render(scene, camera);
      }

      function clearPickPosition() {
        pickPosition.x = -100000;
        pickPosition.y = -100000;
        render();
      }
      clearPickPosition();

      function setPickPosition(event) {
        const pos = getCanvasRelativePosition(event);
        pickPosition.x = (pos.x / canvas.width) * 2 - 1;
        pickPosition.y = (pos.y / canvas.height) * -2 + 1;
        render();
      }

      window.addEventListener('mouseout', clearPickPosition);
      window.addEventListener('mouseleave', clearPickPosition);
      window.addEventListener('mousemove', setPickPosition);

      //Support mobile devices too
      window.addEventListener('touchstart', (event) => {
        event.preventDefault()
        setPickPosition(event.touches[0]);
      }, {passive: false});

      window.addEventListener('touchmove', (event) => {
        setPickPosition(event.touches[0]);
      });

      window.addEventListener('touchend', clearPickPosition);

      //Set up buttons for the user: a Graphical User Interface
      const gui = new GUI();
      gui.add(location, 'reload').name('Next Event'); //Reload the page to go to the next event.  This is just how the ART process backend works.
      gui.add(geomMaterial, "opacity", 0, 1, 0.1).name("Geom Opacity").onChange(render);
      gui.add(ssdMaterial, "opacity", 0, 1, 0.1).name("SSD Opacity").onChange(render);

      render();

      controls.addEventListener('change', render);
      window.addEventListener('resize', render);
    }
    
    main();

    </script>
    <!-- Can I print any text here? -->
  </body>
</html>
