#!/usr/bin/perl
# Prototype by Linyan 2022.01
# Code heavily copied from Nova geometry package

#
# Build a description of the detectors from gdml fragments
#

# Use the command line arguments to give us the list of file fragments
# that we'll zip together.  The man page for 'GetOptions' can be read
# with: perldoc Getopt::Long

use Getopt::Long;
GetOptions( "input|i:s" => \$input,
	    "help|h" => \$help,
	    "output|o:s" => \$output);

if ( defined $help )
{
    # If the user requested help, print the usage notes and exit.
    usage();
    exit;
}

if ( ! defined $input )
{
    # If the user has not used "-i", then just take the first
    # non-option argument.
    if ( $#ARGV > -1 )
    {
	$input = $ARGV[0];
	if ( ! -r $input )
	{
	    print "Input file $input not found\n";
	    usage();
	    exit;
	}
    }
    else
    {
	# Read from STDIN
	$input = "-"; 
    }
}
else
{
    # The "-i" option was provided; check that the input file exists.
    if ( ! -r $input )
    {
	print "Input file $input not found or cannot be read\n";
	usage();
	exit;
    }
}

if ( ! defined $output )
{
    $output = "-"; # write to STDOUT 
}


# Find the gdml file names to be pasted together.  To avoid dependence on
# Perl's libXML, which isn't installed on our machines, this is done by
# stupidly parsing the input file and assuming that any word ending in .gdml
# indicates a file to be read.  It will fail hilariously if such strings appear
# elsewhere in the file.

open FILE, $input or die("Could not open file $FILE for read.");

# Read the entire file into an array.
$/ = ' ';
@words = <FILE>;
close(FILE);

@gdmlFiles = grep(/\.gdml/, @words);

# Keep track of how many constants we read in.
$numberConstants = -1;


# The main GDML keywords, used in tags. The order here is important:
# No matter what order these blocks are in the sub-files, this is the
# order in which they must be written in the final GDML output.

@keywords = qw( define materials solids structure );

# For each node that's a file of GDML statements...
foreach $filename ( @gdmlFiles )
{

    # Open the file.
    open FILE, $filename or die("Could not open file $FILE for read");

    # Read the entire file into an array.
    @file = <FILE>;
    close(FILE);

    # Slurp the array into a single variable.
    $file = join("",@file);

    foreach $keyword ( @keywords )
    {
	# Search the file for a keyword block. For example, if
	# $keyword were "blorg", the following would search for
	# <blorg>some text</blorg> and snip it out of $file.
	while ( $file =~ s/(.*)\<$keyword\>(.*?)\<\/$keyword\>(.*)/\1\3/s )
	{
	    # Following the above example, this would append "some
	    # text" to $keyhash{blorg}

	    $keyhash{$keyword} = $keyhash{$keyword} . $2;
	}
    }
}

# Write the final GDML file.

$OUTPUT = ">" . $output;
open(OUTPUT) or die("Could not open $output for writing");

# The preliminary material for the GDML file. This defines the GDML
# schema and namespaces.

print OUTPUT <<EOF;
<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<gdml xmlns:gdml="http://cern.ch/2001/Schemas/GDML" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="GDMLSchema/gdml.xsd">


<!--
  WARNING: This file is automatically generated. It is a bad idea to
  edit it directly. 
--> 

EOF

# Print to OUTPUT all the GDML sections, with each set of tags
# unified, in the appropriate order.

foreach $keyword ( @keywords )
{
    print OUTPUT "<$keyword>";

    # Substitute any constants in the GDML with their numeric
    # equivalents. 

    # In strict GDML, this should not be necessary; according to the
    # specification, you should be able to define a constant and use
    # it in subsequent GDML statements. If you use the standard GDML
    # parser, this not a problem. ROOT, however, uses its own parser,
    # and (as of ROOT 5.16) it could not handle variables in GDML
    # expressions. So here we side-step the problem by performing our
    # own substitutions.

    # Step through this list of constants in reverse order, to resolve
    # any dependencies.

    for ( $i = $numberConstants; $i >= 0; --$i ) 
    {
	$keyhash{$keyword} =~ s/$name[$i]/$value[$i]/g;
    }

    # Print the edited section. 
    print OUTPUT $keyhash{$keyword};

    print OUTPUT "</$keyword>\n";
}

# The final section of a GDML file is the <setup></setup> section. At
# present, we don't define alternate setups in the same GDML file, so
# these lines are constant.

print OUTPUT <<EOF;

<setup name="Default" version="1.0">
  <world ref="world" />
</setup>

</gdml>
EOF

close(OUTPUT);


sub usage()
{
    print "Usage: $0 [-h|--help] [-i|--input <xml-fragments-file>] [-o|--output <output-file>]\n";
    print "       -i/--input can be omitted; if no input file, defaults to STDIN\n";
    print "       if -o is omitted, output goes to STDOUT\n";
    print "       -h prints this message, then quits\n";
}
