// This file was auto-generated by SRProxy's gen_srproxy.
// DO NOT EDIT IT DIRECTLY.

#pragma once

#include "TVector3.h"

#include "SRProxy/BasicTypesProxy.h"

#include "StandardRecord/Proxy//FwdDeclare.h"


/// Proxy for \ref caf::SRHeader
template<> class caf::Proxy<caf::SRHeader>
{
public:
  Proxy(TDirectory* d, TTree* tr, const std::string& name, const long& base, int offset);
  Proxy(TTree* tr, const std::string& name) : Proxy(0, tr, name, 0, 0) {}
  Proxy(const Proxy&) = delete;
  Proxy(const Proxy&&) = delete;
  Proxy& operator=(const caf::SRHeader& x);

  void CheckEquals(const caf::SRHeader& sr) const;

  caf::Proxy<unsigned int> evt;
  caf::Proxy<unsigned int> run;
  caf::Proxy<unsigned int> subrun;
};

/// Proxy for \ref caf::SRVector3D
template<> class caf::Proxy<caf::SRVector3D>
{
public:
  Proxy(TDirectory* d, TTree* tr, const std::string& name, const long& base, int offset);
  Proxy(TTree* tr, const std::string& name) : Proxy(0, tr, name, 0, 0) {}
  Proxy(const Proxy&) = delete;
  Proxy(const Proxy&&) = delete;
  Proxy& operator=(const caf::SRVector3D& x);

  void CheckEquals(const caf::SRVector3D& sr) const;
// Extra utility functions from SRVector3DAddons.h

float X() const {return x;}
float Y() const {return y;}
float Z() const {return z;}

operator TVector3() const {return TVector3(x, y, z);}

float Mag2() const {return x*x+y*y+z*z;}
float Mag() const {return sqrt(Mag2());}
float Dot(const Proxy& v) const {return x*v.x + y*v.y + z*v.z;}
float Dot(const TVector3& v) const {return x*v.X() + y*v.Y() + z*v.Z();}
TVector3 Unit() const
{
  const float m = Mag();
  return TVector3(x/m, y/m, z/m);
}

  caf::Proxy<float> x;
  caf::Proxy<float> y;
  caf::Proxy<float> z;
};

/// Proxy for \ref caf::SRARing
template<> class caf::Proxy<caf::SRARing>
{
public:
  Proxy(TDirectory* d, TTree* tr, const std::string& name, const long& base, int offset);
  Proxy(TTree* tr, const std::string& name) : Proxy(0, tr, name, 0, 0) {}
  Proxy(const Proxy&) = delete;
  Proxy(const Proxy&&) = delete;
  Proxy& operator=(const caf::SRARing& x);

  void CheckEquals(const caf::SRARing& sr) const;

  caf::Proxy<caf::SRVector3D> center;
  caf::Proxy<short unsigned int> nhit;
  caf::Proxy<float> radius;
};

/// Proxy for \ref caf::SRARingBranch
template<> class caf::Proxy<caf::SRARingBranch>
{
public:
  Proxy(TDirectory* d, TTree* tr, const std::string& name, const long& base, int offset);
  Proxy(TTree* tr, const std::string& name) : Proxy(0, tr, name, 0, 0) {}
  Proxy(const Proxy&) = delete;
  Proxy(const Proxy&&) = delete;
  Proxy& operator=(const caf::SRARingBranch& x);

  void CheckEquals(const caf::SRARingBranch& sr) const;

  caf::Proxy<std::vector<caf::SRARing>> arich;
  caf::Proxy<size_t> narich;
};

/// Proxy for \ref caf::StandardRecord
template<> class caf::Proxy<caf::StandardRecord>
{
public:
  Proxy(TDirectory* d, TTree* tr, const std::string& name, const long& base, int offset);
  Proxy(TTree* tr, const std::string& name) : Proxy(0, tr, name, 0, 0) {}
  Proxy(const Proxy&) = delete;
  Proxy(const Proxy&&) = delete;
  Proxy& operator=(const caf::StandardRecord& x);

  void CheckEquals(const caf::StandardRecord& sr) const;

  caf::Proxy<caf::SRHeader> hdr;
  caf::Proxy<caf::SRARingBranch> ring;
};
