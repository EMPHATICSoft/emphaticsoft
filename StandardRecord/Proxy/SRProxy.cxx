// This file was auto-generated by SRProxy's gen_srproxy.
// DO NOT EDIT IT DIRECTLY.

#include "StandardRecord/Proxy//SRProxy.h"

#include "StandardRecord/StandardRecord.h"

namespace
{
  std::string Join(const std::string& a, const std::string& b)
  {
    if(a.empty()) return b;
    return a+"."+b;
  }
}

caf::Proxy<caf::SRHeader>::Proxy(TDirectory* d, TTree* tr, const std::string& name, const long& base, int offset) :
  evt(d, tr, Join(name, "evt"), base, offset),
  run(d, tr, Join(name, "run"), base, offset),
  subrun(d, tr, Join(name, "subrun"), base, offset)
{
}

caf::Proxy<caf::SRHeader>& caf::Proxy<caf::SRHeader>::operator=(const caf::SRHeader& sr)
{
  evt = sr.evt;
  run = sr.run;
  subrun = sr.subrun;
  return *this;
}

void caf::Proxy<caf::SRHeader>::CheckEquals(const caf::SRHeader& sr) const
{
  evt.CheckEquals(sr.evt);
  run.CheckEquals(sr.run);
  subrun.CheckEquals(sr.subrun);
}

caf::Proxy<caf::SRVector3D>::Proxy(TDirectory* d, TTree* tr, const std::string& name, const long& base, int offset) :
  x(d, tr, Join(name, "x"), base, offset),
  y(d, tr, Join(name, "y"), base, offset),
  z(d, tr, Join(name, "z"), base, offset)
{
}

caf::Proxy<caf::SRVector3D>& caf::Proxy<caf::SRVector3D>::operator=(const caf::SRVector3D& sr)
{
  x = sr.x;
  y = sr.y;
  z = sr.z;
  return *this;
}

void caf::Proxy<caf::SRVector3D>::CheckEquals(const caf::SRVector3D& sr) const
{
  x.CheckEquals(sr.x);
  y.CheckEquals(sr.y);
  z.CheckEquals(sr.z);
}

caf::Proxy<caf::SRARing>::Proxy(TDirectory* d, TTree* tr, const std::string& name, const long& base, int offset) :
  center(d, tr, Join(name, "center"), base, offset),
  nhit(d, tr, Join(name, "nhit"), base, offset),
  radius(d, tr, Join(name, "radius"), base, offset)
{
}

caf::Proxy<caf::SRARing>& caf::Proxy<caf::SRARing>::operator=(const caf::SRARing& sr)
{
  center = sr.center;
  nhit = sr.nhit;
  radius = sr.radius;
  return *this;
}

void caf::Proxy<caf::SRARing>::CheckEquals(const caf::SRARing& sr) const
{
  center.CheckEquals(sr.center);
  nhit.CheckEquals(sr.nhit);
  radius.CheckEquals(sr.radius);
}

caf::Proxy<caf::SRARingBranch>::Proxy(TDirectory* d, TTree* tr, const std::string& name, const long& base, int offset) :
  arich(d, tr, Join(name, "arich"), base, offset),
  narich(d, tr, Join(name, "narich"), base, offset)
{
}

caf::Proxy<caf::SRARingBranch>& caf::Proxy<caf::SRARingBranch>::operator=(const caf::SRARingBranch& sr)
{
  arich = sr.arich;
  narich = sr.narich;
  return *this;
}

void caf::Proxy<caf::SRARingBranch>::CheckEquals(const caf::SRARingBranch& sr) const
{
  arich.CheckEquals(sr.arich);
  narich.CheckEquals(sr.narich);
}

caf::Proxy<caf::StandardRecord>::Proxy(TDirectory* d, TTree* tr, const std::string& name, const long& base, int offset) :
  hdr(d, tr, Join(name, "hdr"), base, offset),
  ring(d, tr, Join(name, "ring"), base, offset)
{
}

caf::Proxy<caf::StandardRecord>& caf::Proxy<caf::StandardRecord>::operator=(const caf::StandardRecord& sr)
{
  hdr = sr.hdr;
  ring = sr.ring;
  return *this;
}

void caf::Proxy<caf::StandardRecord>::CheckEquals(const caf::StandardRecord& sr) const
{
  hdr.CheckEquals(sr.hdr);
  ring.CheckEquals(sr.ring);
}
