{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\csgray\c0\c0;}
\margl1440\margr1440\vieww12020\viewh13240\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \expnd0\expndtw0\kerning0
Some rules of algebra do not apply with floating-point numbers. For example, the law of associativity doesn\'92t hold in floating-point arithmetics, i.e.\
\pard\pardeftab720\qc\partightenfactor0
\cf2 (a + b) + c \uc0\u8800  a + (b + c)\
\pard\pardeftab720\partightenfactor0
\cf2 If a is 10
\fs20 \super 30
\fs28 \nosupersub , b is -10
\fs20 \super 30
\fs28 \nosupersub  and c is 1, the expression (a + b) + c gives 1, but a + (b + c) which gives 0 as the result.  Strict IEEE 754 semantics will disallow approximative instructions and optimizations using algebraic transformations that can influence the precision of the result.\
\
Compilers provide an optimization flag that enables many floating-point optimizations that result in a faster code, but with no guarantees about the precision of the result. This flag is 
\f1 \cb3 -ffast-math
\f0  \cb1 for CLANG and GCC, and it is not enabled by default in any optimization level.\
\
If you cannot enable 
\f1 \cb3 -ffast-math
\f0 \cb1  because of the precision loss, you should consider optimizing the handling of error conditions in floating point operations.\
\
In C/C++, before IEEE 754 exceptions, floating-point errors were signaled through the 
\f1 \cb3 errno
\f0 \cb1  variable defined in
\fs32  
\f1\fs28 \cb3 <errno.h>
\f0 \cb1 . This mechanism continues to be employed today in library mathematical functions, such as 
\f1 \cb3 sqrt
\f0 \cb1  or 
\f1 \cb3 log10
\f0 \cb1 . Here is an example:\
\
\pard\pardeftab720\partightenfactor0

\f1 \cf2 \cb3 	errno = 0;\
	double result = sqrt(something)\
	if (errno == EDOM) freak_out();\
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \cb1 \
Setting 
\f1 \cb3 errno
\f0 \cb1  costs some time, as does checking it.  The 
\f1 \cb3 -fno-math-errno
\f0 \cb1  flag (for GCC and CLANG) suppresses the setting of 
\f1 \cb3 errno
\f0 \cb1 , and results in considerable times savings in many cases.\
\
Perhaps you will find IEEE \'93traps\'94 useful.  These are not C++ exceptions; these are different cases of what happens when the SIGFPE signal is generated by the process and handled by a signal handler.  To be honest, I am not sure if they are really any faster, or if one can use them with 
\f1 \cb3 -fno-math-errno
\f0 \cb1  set.}