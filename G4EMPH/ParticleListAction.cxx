////////////////////////////////////////////////////////////////////////
/// \brief Use Geant4's user "hooks" to maintain a list of particles generated by Geant4.
///
/// \author  seligman@nevis.columbia.edu, brebel@fnal.gov
////////////////////////////////////////////////////////////////////////
// G4EMPH Includes
#include "G4EMPH/ParticleListAction.h"
#include "G4Base/PrimaryParticleInformation.h"
#include "Simulation/Particle.h"
#include "Simulation/ParticleNavigator.h"
#include "Simulation/Simulation.h"

#include "G4Base/UserActionFactory.h"
USERACTIONREG3(emph, ParticleListAction, emph::ParticleListAction)

// G4 includes
#include "Geant4/G4Event.hh"
#include "Geant4/G4Track.hh"
#include "Geant4/G4ThreeVector.hh"
#include "Geant4/G4ParticleDefinition.hh"
#include "Geant4/G4PrimaryParticle.hh"
#include "Geant4/G4DynamicParticle.hh"
#include "Geant4/G4VUserPrimaryParticleInformation.hh"
#include "Geant4/G4Step.hh"
#include "Geant4/G4StepPoint.hh"
#include "Geant4/G4VProcess.hh"

// ROOT includes
#include <TLorentzVector.h>

// C/C++ includes
#include <algorithm>
#include <string>

// ART includes
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"

namespace emph {

  // Initialize static members.
  sim::Particle* ParticleListAction::fParticle       = 0;
  int            ParticleListAction::fCurrentTrackID = sim::kNoParticleId;
  int            ParticleListAction::fTrackIDOffset  = 0;

  //-------------------------------------------------------------
  // Constructor.
  ParticleListAction::ParticleListAction(double energythres,
                                         bool manyParticles)
    : fIsAborted             (false)
    , fEnergyCut             (energythres*CLHEP::GeV)
    , fManyParticles         (manyParticles)
  {
    // Create the particle list that we'll (re-)use during the course
    // of the Geant4 simulation.
    fParticleNav  = new sim::ParticleNavigator();
  }

  //-------------------------------------------------------------
  // Destructor.
  ParticleListAction::~ParticleListAction()
  {
    // Delete anything that we created with "new'.
    delete fParticleNav;
  }

  //-------------------------------------------------------------
  void ParticleListAction::Config(fhicl::ParameterSet const& pset )
  {
    fEnergyCut              = pset.get< double >("G4EnergyThreshold")*CLHEP::GeV;
    fManyParticles          = pset.get< bool   >("ManyParticles");
  }

  //-------------------------------------------------------------
  void ParticleListAction::PrintConfig(std::string const& /* opt */)
  {
    mf::LogInfo("ParticleListAction")
      << "ParticleListAction::PrintConfig"
      << "\n  EnergyCut          " << fEnergyCut
      << "\n  ManyParticles      " << (fManyParticles?"true":"false");
  }
  
  //-------------------------------------------------------------
  void ParticleListAction::BeginOfEventAction(const G4Event*)
  {
    // Clear any previous particle information.
    fParticle = 0;
    fParentIDMap.clear();
    fParticleNav->clear();
    fTrackIDToMCTruthIndex.clear();

    fCurrentTrackID = sim::kNoParticleId;

  }

  //-------------------------------------------------------------
  // figure out the ultimate parentage of the particle with track ID
  // trackid
  // assume that the current track id has already been added to
  // the fParentIDMap
  int ParticleListAction::GetParentage(int trackid) const
  {
	 int parentid = sim::kNoParticleId;
	 std::cerr << "Get Parentage!!!!!!! for track ID " << trackid << std::endl;
   
	 // search the fParentIDMap recursively until we have the parent id 
	 // of the first EM particle that led to this one
	 std::map<int,int>::const_iterator itr = fParentIDMap.find(trackid);
	 
	int nIterations = 0;
	 while( itr != fParentIDMap.end() ){
		 std::cerr << "Iterating" << " Track ID: " << trackid << "itr: " << (*itr).second << std::endl;
     		 MF_LOG_DEBUG("ParticleListAction") << "parentage for " << trackid
					 << " " << (*itr).second;
      		 // set the parentid to the current parent ID, when the loop ends
      		 // this id will be the first EM particle
		 parentid = (*itr).second;
		 itr = fParentIDMap.find(parentid);
   		 //  std::cerr << "Parent ID: " << parentid << std::endl;

   		 //if ( parentid == (*itr).second ) {return parentid;}
   		 // if the current id matches its parent, then exit the loop and return the current id.
		++nIterations;
		if (nIterations > 20){return parentid;}
   		 }



	 MF_LOG_DEBUG("ParticleListAction") << "final parent ID " << parentid;

	 return parentid;
 }

  //-------------------------------------------------------------
  // Create our initial sim::Particle object and add it to the sim::ParticleList.
  void ParticleListAction::PreTrackingAction(const G4Track* track)
  {

	const G4int trackID = track->GetTrackID() + fTrackIDOffset;	// get the track ID for this particle
	fCurrentTrackID = trackID;					// set the fCurrentTrackID to the actual, real, current particle
	size_t mcTruthIndex = 0;					// set the index of this particle in the truth record to 0
	
	const G4ParticleDefinition*      partdef = track->GetDefinition();      // on our way to get an MCTruth object assoc. with this track...
        const G4int                      pdg = partdef->GetPDGEncoding();       // get the particle type
        const G4DynamicParticle*         dp = track->GetDynamicParticle();      //
        const G4PrimaryParticle*         pp = dp->GetPrimaryParticle();         // its a surprise tool that'll help us later...

	std::cerr << "%%%%% New Particle: trackID = " << trackID << " PDG: " << pdg <<" %%%%%" << std::endl;	

	G4int parentID = track->GetParentID() + fTrackIDOffset;			// get the parent id from Geant for free
	
	std::cerr << "Got immediate parent: parentID = " << parentID << std::endl;
	
	auto trackPos = track->GetPosition();				// get the particle position
	
	std::cerr << "Got Position..." << std::endl;	

	const G4double energy = track->GetKineticEnergy();		// get the kinetic energy
	float fEnergyCut = 1;						// arbitrary energy cutoff for weak, pitiful, unimportant particles

	std::string process_name;					// something to record the process by which this particle was produced...
	
	if (pp != 0){							// if this is a primary particle, we do something special because it's special)
		std::cerr << "Primary Particle!" << std::endl;
		const G4VUserPrimaryParticleInformation* gppi = pp->GetUserInformation();
		const g4b::PrimaryParticleInformation* ppi = dynamic_cast<const g4b::PrimaryParticleInformation*>(gppi);	// no idea what this does
		
		if (ppi != 0){
			process_name = "Primary";
			parentID = 0;					// even primary particles deserve a parent... in this case, it's 0
			mcTruthIndex = ppi->MCTruthIndex();		// grab the index for the primary particle
		}
		else{
			throw cet::exception("ParticleListAction") << "ppi = 0 for trackid " << trackID << std::endl;
		}
	}	
	else{						// if it is not a primary particle, it may be part of the EM shower
							// we don't want to keep a bunch of electrons, so we will go back and find
							// the parent of the particle that isn't another shower-er
		process_name = track->GetCreatorProcess()->GetProcessName();	// record the particle's process
		
		std::cerr << "Secondary Particle! Process: " << process_name << std::endl;

		if( !fManyParticles && (process_name.find("conv")               != std::string::npos
                              || process_name.find("LowEnConversion") != std::string::npos
                              ||(process_name.find("Pair")            != std::string::npos) // && fisFirstPairRecorded)
                              || process_name.find("compt")           != std::string::npos
                              || process_name.find("Compt")           != std::string::npos
                              ||(process_name.find("Brem")            != std::string::npos) // && fisFirstBremRecorded)
                              || process_name.find("phot")            != std::string::npos
                              || process_name.find("Photo")           != std::string::npos
                              || process_name.find("Ion")             != std::string::npos
                              || process_name.find("annihil")         != std::string::npos)) {
			
			fParentIDMap.emplace(fCurrentTrackID, parentID);		// to start finding the parent, we add the particle and its
											// parent to the map: fCurrentTrackID --> parentID
			std::cerr << "Shower Particle! Added " << fCurrentTrackID << " and " << parentID << " to the fParentIDMap" << std::endl;
			
			fCurrentTrackID = this->GetParentage(fCurrentTrackID);		// use the GetParentage function to get the ultimate parent, then 
											// set our 'eyes' on it--the fCurrentTrackID
			
			std::cerr << "Getting ultimate parentage... got " << fCurrentTrackID << " as ult parent for " << fCurrentTrackID << std::endl;
			
											// check if the immediate parent is in the particle list
			if (fParticleNav->find(parentID) == fParticleNav->end()){// if it isn't...
				std::cerr << "Immediate parent " << parentID << " isn't in fParticleNav... checking ultimate..." << std::endl;
				
				if (fParticleNav->find(fCurrentTrackID) == fParticleNav->end()){ // if it still isn't, give up
					std::cerr << "Ultimate parent not in fParticleNav... giving up..." << std::endl;
					fCurrentTrackID = sim::kNoParticleId;			
					fParticle = 0;						// reset, skip the whole particle
					return;
				}
				else{
					parentID = fCurrentTrackID;			// set the parentID to be the relevant parent, the one that's
					std::cerr << "Changing parentID to " << fCurrentTrackID	<< std::endl;	// in the particlenav
				}
			}
				
			
			if (energy < fEnergyCut){	// if the particle is below the energy cut, we should not add it to the list, and skip it
                                fParticle = 0;          // we do not want to step this particle, so setting fParticle to 0 is ?needed?
                                return;
			}
			
											// we attempt to find the mctruth index for the particle
			if (fTrackIDToMCTruthIndex.count(trackID) > 0){
				mcTruthIndex = fTrackIDToMCTruthIndex.at(trackID);
			}
			else if (fTrackIDToMCTruthIndex.count(parentID) > 0){		// or it's relevant parent,
				mcTruthIndex = fTrackIDToMCTruthIndex.at(parentID);
			}
			else{								// if we can't, throw exeption, something is wrong
				throw cet::exception("ParticleListAction") << "Cannot find MCTruth index for trackid " << trackID << " or parentid: "
										<< parentID << std::endl;
			}
			
			if (process_name.empty()){process_name = "unknown";}		// protect against an empty process name
			
		}	
	}
	
	// now that we have an MCTruth index, we can make a sim::Particle object
	fParticle = new sim::Particle(fCurrentTrackID, pdg, process_name, parentID, dp->GetMass()/CLHEP::GeV);
	
	const G4ThreeVector& polarization = track->GetPolarization();			// and make a polarization vector
	fParticle->SetPolarization(TVector3(polarization.x(), polarization.y(), polarization.z()));

	fParticleNav->Add(fParticle);

	if (fTrackIDToMCTruthIndex.count(trackID) > 0){
		fTrackIDToMCTruthIndex.emplace(trackID, mcTruthIndex);
	}

	return;
}	

	

/*    
    // get the track ID for this particle
    const G4int trackID = track->GetTrackID() + fTrackIDOffset;
    fCurrentTrackID = trackID;
    size_t mcTruthIndex = 0;
    
    // get the parent id from Geant for the current track:
    G4int parentID = track->GetParentID() + fTrackIDOffset;
    std::cerr << "Got Parent ID" << parentID << " for track ID " << trackID << std::endl;
    // Is there an MCTruth object associated with this G4Track?  We
    // have to go up a "chain" of information to find out:
    const G4ParticleDefinition* partdef = track->GetDefinition();
    const G4int                 pdg     = partdef->GetPDGEncoding();
    const G4DynamicParticle*    dp      = track->GetDynamicParticle();
    const G4PrimaryParticle*    pp      = dp->GetPrimaryParticle();

    std::cerr << "Getting Stuff" << std::endl;

    // was MF_LOG_DEBUG
    MF_LOG_INFO("ParticleListAction") << "preparing to track " << fCurrentTrackID
				       << " pdg " << pdg
				       << " with parent " << parentID;

    auto trackPos = track->GetPosition();
    MF_LOG_INFO("ParticleListAction") << "Track has start position = (" <<
      trackPos[0] << "," << trackPos[1] << "," << trackPos[2] << ")" << 
      std::endl;
    

    std::cerr << "Got Position" << std::endl;

    std::string process_name;
    if ( pp != 0 ){
      const G4VUserPrimaryParticleInformation* gppi = pp->GetUserInformation();
      const g4b::PrimaryParticleInformation* ppi = dynamic_cast<const g4b::PrimaryParticleInformation*>(gppi);
      
      if ( ppi != 0 ){
	//	std::cerr << "%%%%% HERE 1 %%%%%" << std::endl;
        std::cerr << "Primary Particle Exists" << std::endl;
        // If we've made it this far, a PrimaryParticleInformation
        // object exists and we are using a primary particle, set the
        // process name accordingly.
        process_name = "Primary";
        
        // primary particles should still have parentID = 0, even
        // if there are multiple MCTruths for this event
        parentID = 0;
	
        mcTruthIndex = ppi->MCTruthIndex();
      }
      
    } // Is there a G4PrimaryParticle?
    else{
      std::cerr << partdef->GetParticleName() << std::endl;
      std::cerr << track->GetVolume()->GetLogicalVolume()->GetName() << std::endl;
      // figure out what process is making this track - skip it if it is
      // one of pair production, compton scattering, photoelectric effect
      // bremstrahlung, annihilation, any ionization - who wants to save
      // a buttload of electrons?
      std::cerr << "Not Primary Particle. Finding Process..." << std::endl;

      process_name = track->GetCreatorProcess()->GetProcessName();
      //      std::cerr << "%%%%% Process = " << process_name << " %%%%%" << std::endl;
      
      if( !fManyParticles && (process_name.find("conv")               != std::string::npos
                              || process_name.find("LowEnConversion") != std::string::npos
                              ||(process_name.find("Pair")            != std::string::npos) // && fisFirstPairRecorded)
                              || process_name.find("compt")           != std::string::npos
                              || process_name.find("Compt")           != std::string::npos
                              ||(process_name.find("Brem")            != std::string::npos) // && fisFirstBremRecorded)
                              || process_name.find("phot")            != std::string::npos
                              || process_name.find("Photo")           != std::string::npos
                              || process_name.find("Ion")             != std::string::npos
                              || process_name.find("annihil")         != std::string::npos)) {

		std::cerr << "%%%%% HERE 2, " << process_name << " // %%%%%" << std::endl;
	
	// find the ultimate parent of this particle that was not a secondary
	// of the EM shower
	// first add this track id and its parent to the fParentIDMap
	fParentIDMap.emplace(fCurrentTrackID, parentID);

       std::cerr << "Added current track to parent id map" << std::endl;
	
	fCurrentTrackID = this->GetParentage(fCurrentTrackID);
	
        std::cerr << "Got Parent" << fCurrentTrackID << std::endl;

	MF_LOG_DEBUG("ParticleListAction") << "current track ID " << fCurrentTrackID;
	
	// check that fCurrentTrackID is in the particle list - it is possible
	// that this particle's parent is a particle that did not get tracked.
	// An example is a parent that was made due to muMinusCaptureAtRest
	// and the daughter was made by the phot process.  The parent likely
	// isn't saved in the particle list because it is below the energy cut
	// which will put a bogus track id value into the sim::IDE object for
	// the sim::SimChannel if we don't check it.
	if(fParticleNav->find(fCurrentTrackID) == fParticleNav->end() ) {
	  std::cerr << "Check fCurrentTrackID, not there yet" << std::endl;
	  fCurrentTrackID = sim::kNoParticleId;
	  
	  // set fParticle to 0 as we are not stepping this particle
	  // and adding trajectory points to it
	  fParticle = 0;
	  
	  MF_LOG_DEBUG("ParticleListAction") << "killing TrackID: " << trackID << " bc EM daughter, "
	 				     << process_name << " " << pdg
	 				     << ", use track id " << fCurrentTrackID;
	  
	  return;
	}// end if part of EM shower, but not primary particle
      
	// Check the energy of the particle.  If it falls below the energy
	// cut, don't add it to our list.
	const G4double energy = track->GetKineticEnergy();
       std::cerr << "Getting Kinetic Energy" << std::endl;
	//	std::cerr << "%%%%% energy = " << energy << "%%%%%" << std::endl;
       std::cerr << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!fEnergyCut: " << fEnergyCut << std::endl << std::endl << std::endl << std::endl;
	if ( energy < fEnergyCut ){
          std::cerr << "Particle is lower than the threshold..." << std::endl;
	  fParticle = 0;
	  MF_LOG_DEBUG("ParticleListAction") << "killing TrackID: " << fCurrentTrackID << " energy/fEnergyCut";
	  
	  // do add the particle to the parent id map though
	  // and set the current track id to be it's ultimate parent
	  // fParentIDMap.emplace(fCurrentTrackID, parentID);  // this also checks if the key is unique.  If so, does nothing. 

          std::cerr << "Before parentage!!!!!!" << std::endl;
          std::cerr << "fCurrentTrackID: " << fCurrentTrackID << " parentID: " << parentID << std::endl;

          std::cerr << "Add particle to the parent id map though" << std::endl;

          std::cerr << "ProcessName: " << process_name << std::endl;

	  //fCurrentTrackID = this->GetParentage(fCurrentTrackID); // Why this ???? 

          std::cerr << "Getting Parent" << std::endl;

	  return;
	}
	
	// check to see if the parent particle has been stored in the particle navigator
	// if not, then see if it is possible to walk up the fParentIDMap to find the
	// ultimate parent of this particle.  Use that ID as the parent ID for this
	// particle      
	if( fParticleNav->find(parentID) == fParticleNav->end() ){
         std::cerr << "Parent Particle will be stored in navigator" << std::endl;
	  // do add the particle to the parent id map
	  // just in case it makes a daughter that we have to track as well
	  fParentIDMap[fCurrentTrackID] = parentID;
	  const int pid = this->GetParentage(parentID);
	  
	  // if we still can't find the parent in the particle navigator,
	  // we have to give up
	  if( fParticleNav->find(pid) == fParticleNav->end() ){
	    mf::LogWarning("ParticleListAction") << "can't find parent id: "
						 << parentID
						 << " in the particle navigator, or fParentIDMap."
						 << " Make " << parentID << " the mother ID for"
						 << " track ID " << fCurrentTrackID
						 << " in the hope that it will aid debugging.";
	  }
	  else
	    parentID = pid;
      std::cerr << "parentID=pid" << std::endl;
	}
	
	// Attempt to find the MCTruth index corresponding to the
	// current particle.  If the fCurrentTrackID is not in the
	// map try the parent ID, if that is not there, throw an
	// exception
	if(fTrackIDToMCTruthIndex.count(fCurrentTrackID) > 0 )
	  mcTruthIndex = fTrackIDToMCTruthIndex.at(fCurrentTrackID);
	else if(fTrackIDToMCTruthIndex.count(parentID) > 0 )
	  mcTruthIndex = fTrackIDToMCTruthIndex.at(parentID);
	else
	  throw cet::exception("ParticleListAction") << "Cannot find MCTruth index for track id "
						     << fCurrentTrackID << " or " << parentID;
      }// end of if/else
      
      // protect against potentially empty process names.
      if     ( process_name.empty() )                         { process_name         = "unknown";}
      
      // Create the sim::Particle object
      fParticle = new sim::Particle(fCurrentTrackID, pdg, process_name,
				    parentID, dp->GetMass()/CLHEP::GeV);
      //part.Print();
      
      // Polarization.
      const G4ThreeVector& polarization = track->GetPolarization();
      fParticle->SetPolarization( TVector3(polarization.x(),
					   polarization.y(),
					   polarization.z() ) );
      
      fParticleNav->Add(fParticle);
      
      if(fTrackIDToMCTruthIndex.count(fCurrentTrackID) > 0)
	MF_LOG_WARNING("ParticleListAction") << "attempting to put " << fCurrentTrackID
					     << " into fTrackIDToMCTruthIndex map "
					     << " particle is\n" << *fParticle;
      
      fTrackIDToMCTruthIndex.emplace(fCurrentTrackID, mcTruthIndex);
    }

    return;

  }
*/

  //-------------------------------------------------------------
  void ParticleListAction::PostTrackingAction( const G4Track* )
  {

  }

  //-------------------------------------------------------------
  // With every step, add to the particle's trajectory - not
  // done for nova - maybe we should?
  void ParticleListAction::SteppingAction(const G4Step* step)
  {
    // disgusting static pointer.. Set to zero above.. Let us not use it The SSD (or ARICH, or..) do store similar information.. 
    // I do not see the point of storing such information.. 

    return;
    if ( !fParticle ) return;
    
    // For the most part, we just want to add the post-step
    // information to the particle's trajectory.  There's one
    // exception: In PreTrackingAction, the correct time information
    // is not available.  So add the correct vertex information here.

    std::cerr << "Stepping into trajecotry point " << fParticle->NumberTrajectoryPoints()+1 << std::endl;

    if ( fParticle->NumberTrajectoryPoints() == 0 ){
      // Get the pre-step information from the G4Step.
      const G4StepPoint* preStepPoint = step->GetPreStepPoint();
      
      const G4ThreeVector position = preStepPoint->GetPosition();
      G4double time = preStepPoint->GetGlobalTime();
      
      // Remember that we use mm, ns, GeV.
      TLorentzVector fourPos(position.x() / CLHEP::mm,
                             position.y() / CLHEP::mm,
                             position.z() / CLHEP::mm,
                             time / CLHEP::ns);
      
      const G4ThreeVector momentum = preStepPoint->GetMomentum();
      const G4double energy = preStepPoint->GetTotalEnergy();
      TLorentzVector fourMom(momentum.x() / CLHEP::GeV,
                             momentum.y() / CLHEP::GeV,
                             momentum.z() / CLHEP::GeV,
                             energy / CLHEP::GeV);

      // Add the first point in the trajectory.
      fParticle->AddTrajectoryPoint( fourPos, fourMom );
    }
    
    // Get the post-step information from the G4Step.
    const G4StepPoint* postStepPoint = step->GetPostStepPoint();
    
    const G4ThreeVector position = postStepPoint->GetPosition();
    G4double time = postStepPoint->GetGlobalTime();
    
    // Remember that LArSoft uses cm, ns, GeV.
    TLorentzVector fourPos(position.x() / CLHEP::mm,
                           position.y() / CLHEP::mm,
                           position.z() / CLHEP::mm,
                           time / CLHEP::ns );
    
    const G4ThreeVector momentum = postStepPoint->GetMomentum();
    const G4double energy = postStepPoint->GetTotalEnergy();
    TLorentzVector fourMom(momentum.x() / CLHEP::GeV,
                           momentum.y() / CLHEP::GeV,
                           momentum.z() / CLHEP::GeV,
                           energy / CLHEP::GeV );
    
    fParticle->AddTrajectoryPoint( fourPos, fourMom );
  }

  //-------------------------------------------------------------
  std::vector<sim::Particle> ParticleListAction::GetList() const
  {
    // fill a vector<sim::Particle> using the sim::ParticleNavigator
    std::vector<sim::Particle> plist;

    // make sure to set the fTrackIDOffset with the highest G4 track id + 100
    // the 100 gives some cushion between lists
    int highestID = 0;
    for(sim::ParticleNavigator::iterator itr = fParticleNav->begin(); itr != fParticleNav->end(); ++itr){
      plist.push_back(*((*itr).second));
      if((*itr).first > highestID) highestID = (*itr).first;
    }

    fTrackIDOffset = highestID + 100;

    MF_LOG_DEBUG("ParticleListAction") << *fParticleNav << "\ntrack id offset is now " << fTrackIDOffset;

    return plist;
  }

  //-------------------------------------------------------------
  std::map<int, size_t> ParticleListAction::TrackIDToMCTruthIndexMap() const
  {
    return fTrackIDToMCTruthIndex;
  }

  //-------------------------------------------------------------
  /// Utility class for the EndOfEventAction method: update the
  /// daughter relationships in the particle list.
  class UpdateDaughterInformation : public std::unary_function<sim::ParticleNavigator::value_type, void>
  {
  public:
    UpdateDaughterInformation()
      : particleNav(0)
    {}
    void SetParticleNav( sim::ParticleNavigator* p ) { particleNav = p; }
    void operator()( sim::ParticleNavigator::value_type& particleNavEntry )
    {
      // We're looking at this Particle in the list.
      sim::Particle* particle = particleNavEntry.second;

      // The parent ID of this particle.
      int parentID = particle->Mother();

      // If the parentID <= 0, this is a primary particle.
      if ( parentID <= 0 ) return;

      // If we get here, this particle is somebody's daughter.  Add
      // it to the list of daughter particles for that parent.

      // Get the parent particle from the list.
      sim::ParticleNavigator::iterator parentEntry = particleNav->find( parentID );

      if ( parentEntry == particleNav->end() ){
        // We have an "orphan": a particle whose parent isn't
        // recorded in the particle list.  This is not signficant;
        // it's possible for a particle not to be saved in the list
        // because it failed an energy cut, but for it to have a
        // daughter that passed the cut (e.g., a nuclear decay).
        return;
      }

      // Add the current particle to the daughter list of the
      // parent.
      sim::Particle* parent = (*parentEntry).second;
      parent->AddDaughter( particle->TrackId() );
    }
  private:
    sim::ParticleNavigator* particleNav;     
  };

  //-------------------------------------------------------------
  // There's one last thing to do: All the particles have their
  // parent IDs set (in PostTrackingAction), but we haven't set the
  // daughters yet.  That's done in this method.
  void ParticleListAction::EndOfEventAction(const G4Event* e)
  {
    // If the event was aborted, we want to keep track of that fact
    // by setting this flag
    if (e->IsAborted()) fIsAborted = true;
    
    // Set up the utility class for the "for_each" algorithm.  (We only
    // need a separate set-up for the utility class because we need to
    // give it the pointer to the particle list.  We're using the STL
    // "for_each" instead of the C++ "for loop" because it's supposed
    // to be faster.
    UpdateDaughterInformation updateDaughterInformation;
    updateDaughterInformation.SetParticleNav( fParticleNav );
    
    // Update the daughter information for each particle in the list.
    std::for_each(fParticleNav->begin(), 
		  fParticleNav->end(), 
		  updateDaughterInformation);
    
    MF_LOG_DEBUG("ParticleListAction") << *fParticleNav;
  }

} // end namespace
